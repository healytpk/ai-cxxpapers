#include <iostream>               // cout, cerr
#include <fstream>                // ifstream, ofstream
#include <sstream>                // ostringstream
#include <filesystem>             // filesystem
#include <vector>                 // vector
#include <sentencepiece_processor.h> // SentencePieceProcessor

namespace fs = std::filesystem;

std::string read_file_to_string(std::string const &filename)
{
    std::ifstream file(filename);
    std::ostringstream ss;
    ss << file.rdbuf();
    return ss.str();
}

std::vector<std::string> chunk_text(std::string const &text, size_t const max_tokens, sentencepiece::SentencePieceProcessor &sp)
{
    std::vector<std::string> pieces;
    sp.Encode(text, &pieces);

    std::vector<std::string> chunks;
    std::string current_chunk;
    size_t token_count = 0u;

    for (auto const &token : pieces)
    {
        if (token_count + 1u > max_tokens)
        {
            chunks.push_back(current_chunk);
            current_chunk.clear();
            token_count = 0u;
        }
        current_chunk += token + " ";
        ++token_count;
    }

    if (false == current_chunk.empty())
    {
        chunks.push_back(current_chunk);
    }

    return chunks;
}

int main(int argc, char *argv[])
{
    if (argc < 3)
    {
        std::cerr << "Usage: " << argv[0] << " <folder_path> <sentencepiece_model>\n";
        return EXIT_FAILURE;
    }

    std::string const folder_path = argv[1];
    std::string const model_path = argv[2];

    sentencepiece::SentencePieceProcessor sp;
    auto const status = sp.Load(model_path);
    if (false == status.ok())
    {
        std::cerr << "Failed to load model: " << status.ToString() << std::endl;
        return EXIT_FAILURE;
    }

    for (auto const &entry : fs::directory_iterator(folder_path))
    {
        if (entry.is_regular_file() && ".txt" == entry.path().extension())
        {
            std::string const text = read_file_to_string(entry.path().string());
            std::vector<std::string> const chunks = chunk_text(text, 256u, sp);

            // Create a separate output file for each input file
            std::ofstream output(entry.path().stem().string() + "_chunks.txt");
            for (auto const &chunk : chunks)
            {
                output << chunk << std::endl;
            }
        }
    }

    return EXIT_SUCCESS;
}
